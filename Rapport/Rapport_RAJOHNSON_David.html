<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Lignes de champs éléctriques</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="tp---ligne-de-champs-éléctriques">TP - Ligne de champs éléctriques</h1>
<h2 id="introduction"><strong>Introduction</strong></h2>
<p>Un champ éléctrique est le champ vectoriel créée par des particules éléctriquement chargées. Quand plusieurs charges sont à proximité de l’autres ces lignes de champs éléctriques diffère prenant en compte prenant en compte si la charges est chargée positivement ou négativement. La visualisation des lignes de champs éléctrique permet d’apercevoir directement ce qui se passe entre plusieurs charges qui pour nous la plupart du temps est invisible à l’oeil nu. Et que le comportement des lignes de champs éléctriques est différent dépendant du nombre de charges et du signe de chaque charge(positif ou négatif). De ce fait nous allons donc voir comment ai-je réaliser la visualisation de ces lignes de champs éléctriques, commençant tout d’abord par la réalisation des dessin de chaque charge. Puis la réalisation du dessin de chaque ligne de champ à partir d’un ensemble de particules dans notre univers. Puis comment j’ai assembler ces deux procédé pour avoir le tout sur l’écran(charges + lignes de champs éléctriques).</p>
<h2 id="réalisation-du-dessin-des-charges-éléctriques"><strong>Réalisation du dessin des charges éléctriques</strong></h2>
<p>Tout d’abord, chaque charge éléctrique sera représenté d’un cercle avec un plus ou moins à l’intérieur dépendant du signe de la charge:</p>
<figure>
<img src="./Images/Dessin_charges.png" alt="Dessin charges à partir de la librairie gfx" /><figcaption>Dessin charges à partir de la librairie gfx</figcaption>
</figure>
<p>Pour représenter les droites du signe plus et moins à l’écran, j’ai utilisé l’algorithme de tracé de droites de Bresenham. Cela permet de tracer chaque pixel de la droite entre deux points pour que la droite soit plus précise sans saut incohérent de pixels comme ci-dessous:</p>
<figure>
<img src="./Images/Trace_Bresenham.png" alt="Tracé de Bresenham(Extrait de wikipédia)" /><figcaption>Tracé de Bresenham(Extrait de wikipédia)</figcaption>
</figure>
<p>Pour le cercle autour de chaque charge, j’ai utilisé l’algorithme de tracé de cercle d’Andres. Cet algorithme permet de tracer des cercles en image matricielle, et donc de pouvoir dessiner un cercle sans laisser de trous. Le principe est de paver entièrement le plan par des cercles concentriques.</p>
<p>En assemblant ces deux différentes méthodes, j’ai pu dessiner le cercle autour de la charge avec un rayon donné puis dessiner le plus et le moins dépendant du signe de la charge. Le signe “plus” se dessine dans mon cas, en traçant une droite verticalement partant de la position de la charge plus ou moins le rayon de charge/2 :<br />
<strong>Point 1</strong>: x=pos(Charge).x+(rayon(Charge)/2) // y=pos(charge).y<br />
<strong>Point 2</strong>: x=pos(Charge).x-(rayon(Charge)/2) // y=pos(charge).y</p>
<p>Et de tracer également une droite horizontalement:<br />
<strong>Point 1</strong>: x=pos(Charge).x // y=pos(Charge).y+(rayon(Charge)/2)<br />
<strong>Point 2</strong>: x=pos(Charge).x // pos(Charge).y-(rayon(Charge)/2)</p>
<p>Pour le signe “moins”, il suffit juste de reprendre le tracé horizontal.</p>
<h2 id="réalisation-de-chaque-ligne-de-champ"><strong>Réalisation de chaque ligne de champ</strong></h2>
<p>Chaque ligne de champ est dans notre cas calculé par rapport à une particule P positionné aléatoirement dans notre univers. Donc pour chaque P, on dessine une ligne de champ. Sachant que P est générer aléatoirement, P peut être positionné à l’intérieur d’une des charges(dans le rayon du cercle de la charge). Dans ce cas là, la ligne de champ pour ce P si ne sera pas dessiner. La ligne de champ sera également limité à la taille de notre fenêtre, donc quand notre ligne de champ excède cette limite on ne dessine plus.<br />
En prenant en compte cette limite, on peut maintenant dessiner notre ligne de champ. Pour cela, on commence tout d’abord par dessiner chaque pixel en commençant par notre P, en appliquant la formule suivante:</p>
<p><br /><span class="math display">$$P _\textit{suivant}=P+\delta \textit{x} \; \cdot \; \frac{\vec{E}}{\|\vec{E}\|}$$</span><br /></p>
<p>On dessine également la ligne de champs dans le sens opposé, pour avoir la totalité de notre ligne de champs avec:</p>
<p><br /><span class="math display">$$P _\textit{suivant}=P-\delta \textit{x} \; \cdot \; \frac{\vec{E}}{\|\vec{E}\|}$$</span><br /></p>
<p>Ici <span class="math inline">$\delta \textit{x} = \frac{1}{\sqrt{largeur^2+hauteur^2}}$</span> et <span class="math inline"><em>E⃗</em></span> est le total de l’intensité du champs pour chaque charge dans notre univers:</p>
<p><br /><span class="math display">$$\vec{E}=\sum_{i=0}^N E_\textit{i} \; \cdot \; \frac{\vec{q_\textit{i}P}}{\|\vec{q_\textit{i}P}\|}$$</span><br /></p>
<p><span class="math inline">$\vec{q_\textit{i}P}$</span> est la distance entre notre particule et chaque charge. Et <span class="math inline"><em>E</em><sub><em>i</em></sub></span>, l’intensité de ce champs à une distance r de chaque particule:</p>
<p><br /><span class="math display">$$E_\textit{i}=k\; \cdot \; \frac{Q}{r^2}$$</span><br /></p>
<p>On a implémenter le calcul de ces lignes de champs en calculant chaque <span class="math inline"><em>P</em><sub><em>suivant</em></sub></span> à l’aide de la librairie de vecteur. Donc dans notre cas, les vecteurs sont calculées par rapport à la taille de notre univers qui est un rectangle de [0;1]×[0;1]:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// Psuivant = P + tetaX * totalE / ||totalE||</span></a>
<a class="sourceLine" id="cb1-2" title="2">vec2 P_next_calculate(vec2 previous_P, <span class="dt">double</span> tetaX, vec2 totalE)</a>
<a class="sourceLine" id="cb1-3" title="3">{</a>
<a class="sourceLine" id="cb1-4" title="4">  vec2 P_next;</a>
<a class="sourceLine" id="cb1-5" title="5">  P_next = vec2_mul(tetaX, totalE);</a>
<a class="sourceLine" id="cb1-6" title="6">  P_next = vec2_div(vec2_norm(totalE), P_next);</a>
<a class="sourceLine" id="cb1-7" title="7">  P_next = vec2_add(previous_P, P_next);</a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="cf">return</span> P_next;</a>
<a class="sourceLine" id="cb1-9" title="9">}</a></code></pre></div>
<p>Le résultat de cette fonction nous donne donc une position dans notre univers. Mais pour le dessiner, il faut qu’on le convertisse en coordonnées. Donc pour cela on a utilisé la fonction donné, <strong>position_to_coordinates(…)</strong>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1">coordinates_t Pnext = position_to_coordinates(SCREEN_HEIGHT, SCREEN_WIDTH, <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-2" title="2">, LIMIT_X, <span class="dv">0</span>, LIMIT_Y, P);</a>
<a class="sourceLine" id="cb2-3" title="3">gfx_putpixel(ctxt, Pnext.column, Pnext.row, color);</a></code></pre></div>
<p>On dessine donc la ligne de champ petit à petit en prenant en compte la limite de l’univers et en prenant en compte la distance avec chaque charge:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// Returns false if pos0 is not a valid position</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="dt">bool</span> in_univers(vec2 p, <span class="dt">double</span> limitX, <span class="dt">double</span> limitY)</a>
<a class="sourceLine" id="cb3-3" title="3">{</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="co">// check if P is in the window</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="cf">return</span> p.x &lt;= limitX &amp;&amp; p.y &lt;= limitY &amp;&amp; p.x &gt;= <span class="fl">0.0</span> &amp;&amp; p.y &gt;= <span class="fl">0.0</span>;</a>
<a class="sourceLine" id="cb3-6" title="6">}</a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">// (for example if pos0 is too close to a charge).</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="dt">bool</span> in_charge(vec2 p, charge_t *charges, <span class="dt">int</span> num_charges, <span class="dt">double</span> eps)</a>
<a class="sourceLine" id="cb3-10" title="10">{</a>
<a class="sourceLine" id="cb3-11" title="11">  <span class="co">// check if P is in the charges(pos(charges)-eps or pos(charges)+eps)</span></a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="co">// if it in the charge don&#39;t draw it</span></a>
<a class="sourceLine" id="cb3-13" title="13">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; num_charges; i++)</a>
<a class="sourceLine" id="cb3-14" title="14">  {</a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="cf">if</span> (p.x &gt; (charges[i].pos.x - eps) &amp;&amp; p.x &lt; (charges[i].pos.x + eps) &amp;&amp;</a>
<a class="sourceLine" id="cb3-16" title="16">        p.y &gt; (charges[i].pos.y - eps) &amp;&amp; p.y &lt; charges[i].pos.y + eps)</a>
<a class="sourceLine" id="cb3-17" title="17">    {</a>
<a class="sourceLine" id="cb3-18" title="18">      <span class="cf">return</span> true;</a>
<a class="sourceLine" id="cb3-19" title="19">    }</a>
<a class="sourceLine" id="cb3-20" title="20">  }</a>
<a class="sourceLine" id="cb3-21" title="21">  <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb3-22" title="22">}</a></code></pre></div>
<p>La fonction <strong>in_univers(…)</strong> permet de verifier si on est toujours dans notre fenêtre donc on continue de dessiner. Et la fonction <strong>in_charge(…)</strong> permet de savoir si on est trop près de la charge dépendant du paramètre <strong>eps</strong>, qui est notre distance limite par rapport à la charge donc si cette fonction retourne vraie, on ne dessine plus la ligne de champs. Dans mon cas, j’ai pris comme limite le rayon du cercle de ma charge:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">//the radius of charge</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="pp">#define CHARGE_RADIUS 10.0</span></a></code></pre></div>
<h2 id="dessin-de-lensemble-de-lunivers"><strong>Dessin de l’ensemble de l’univers</strong></h2>
<p>En assemblant les deux procédés précédant on obtient l’ensemble de nos charges et et le nombres de lignes de champs dépendant du nombre de particules générer aléatoirement dans notre univers. Les charges sont également placés aléatoirement avec la fonction suivante:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="co">//return a random position beetween 0 and 1</span></a>
<a class="sourceLine" id="cb5-2" title="2">vec2 randomPos() { <span class="cf">return</span> (vec2){.x = rand_one(), .y = rand_one()}; }</a></code></pre></div>
<p>Dans notre cas, la valeur de la charge donc le signe également sont générés aléatoirement.</p>
<h2 id="résultats"><strong>Résultats</strong></h2>
<p>Pour représenter les lignes de champs on a placer tout d’abord les charges de manière à représenter joliement les lignes de champs. Ci-dessous on a deux charges positives, on peut voir que les deux charges se repoussent entre eux:</p>
<figure>
<img src="./Images/deux_charges_positives.png" alt="Lignes de champs de deux charges positives" /><figcaption>Lignes de champs de deux charges positives</figcaption>
</figure>
</body>
</html>
